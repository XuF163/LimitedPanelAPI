# 第二次重构计划（TypeScript v2 Roadmap）

> 更新时间：2026-01-22  
> 说明：本文档替代旧版“Rust 方案”路线。**后续以 TypeScript 为唯一实现语言**（运行期仍为 Node.js），并逐步清理 `rust/` 相关目录、二进制与配置项。

目标：在保持 `npm start` 一键启动、输出 JSON 与现有 `PlayerData`/meta 兼容的前提下，完成 **TS 二次重构**（更好兼容 JS 源数据）并在重构后落地：

- **智能并发 + 指数退避**（不再允许手动设置并发上限）
- **动态扩充代理池**（运行期持续补齐、淘汰、轮换）
- **前后端目录结构优化**（更清晰的 server/ui/shared 分层）

实施清单与验收口径：见 `docs/v2-实施清单.md`。

---

## 0. 范围与约束

### 0.1 需要保证的兼容性

- **对外 JSON**：`/presets/<game>/<uid>.json` 与 `/<game>/hyperpanel` 的结构保持兼容（与 miao-plugin/liangshi-calc 的 `PlayerData` 口径一致）。
- **JS 源数据兼容**：所有“来自 JS 世界”的输入（SQLite 读出的 JSON、旧代码产出的对象、Enka raw、第三方插件资源）统一走 **Compat/Normalize 层**，避免 TS 类型“看起来对”但运行期崩溃。

### 0.2 明确弃用

- 不再新增任何 Rust 组件、Rust 环境变量、Rust 二进制依赖。
- 文档层面：`ENKA_FETCHER`、`LIMITEDPANEL_RS_BIN`、`PROXY_SUB_PARSER` 等配置/环境变量视为旧版遗留（v2 将删除/忽略）。

---

## 1. 目标架构（v2）

保持单进程启动（`npm start`），但内部明确拆分为 4 个子系统（全部 TS）：

1) **ProxyPool Manager（代理池管理）**
- 订阅拉取/缓存/解析（多协议）
- 内核适配（v2ray/xray/mihomo/sing-box 等，按能力自动选择）
- 运行期动态维护池：补齐/淘汰/轮换/黑名单

2) **Enka Scanner（扫描器）**
- 以“任务队列 + 调度器”组织 `gs/sr/zzz` 扫描
- 统一错误分类（429/424/超时/HTML/WAF/格式异常）
- 产出：raw（SQLite）+ samples（jsonl）+ 指标

3) **Adaptive Concurrency Controller（自适应并发控制器）**
- **并发数由系统自动推导**，不开放“并发上限”配置
- 在代理池大小、失败率、429 频率、超时等信号下动态调节
- 失败场景采用 **指数退避 + 抖动（jitter）**，避免同步风暴

4) **Panel Builder（极限面板生成）**
- 基于 samples 生成各游戏 hyperpanel JSON
- 评分/构造规则继续对齐现有 meta 口径（可逐步 TS 化，但不强制一次到位）

WebUI：只做“配置/状态/触发”，不参与重计算。

---

## 2. 目录结构优化（前后端拆分）

当前 `src/` 目录下混放 server/业务/前端资源，v2 的目标结构建议如下（示例）：

```
temp/LimitedPanelAPI/
  src/
    server/               # HTTP 服务、路由、鉴权、静态资源托管
    ui/                   # WebUI 静态资源（index.html + assets）
    core/                 # scanner / proxy-pool / preset builder（纯业务，不直接依赖 express）
    shared/               # TS 类型、schema、错误码、日志规范
    compat/               # JS 源数据兼容层：normalize/parse/guard
  dist/                   # TS 编译产物（运行期入口只引用 dist）
```

原则：
- `core/` 不直接 import `server/`（避免反向依赖）。
- `compat/` 只做“把 unknown 变成可用数据”，不做业务决策。
- `ui/` 只依赖 `server/` 提供的 JSON API，不读文件系统/DB。

---

## 3. 重构完成后：智能并发（指数退避）

### 3.1 为什么不再开放“并发上限”

并发上限一旦暴露给用户，常见结果是：

- 配置被误调到过高 → 429/封禁/大量超时 → 吞吐反而下降；
- 不同网络/代理质量下“最佳并发”差异极大 → 文档很难给出安全默认值。

因此 v2 采取：**不允许手动设置并发上限**，由系统根据实时信号调节。

### 3.2 建议的控制策略（实现指引）

- 初始并发：`1`（或“可用代理数的保守子集”）
- 成功窗口内逐步提升并发（温和爬升）
- 出现以下信号之一立即降级并进入退避：
  - `429`（强信号）
  - 超时/连接错误
  - 返回 HTML/WAF
- 退避：`backoffMs = min(maxMs, baseMs * 2^k) + jitter`
- 退避粒度建议按“目标域名 + 代理桶”分别记录（避免一个烂代理拖垮全局）

WebUI 展示建议：当前并发、退避等级 `k`、最近 1min 的成功率/429/超时计数。

---

## 4. 动态扩充代理池（运行期闭环）

目标：池不再是“启动时选出 N 个就固定”，而是持续维持“可用容量”。

闭环信号：

- Scanner 发现某代理桶出现连续失败/HTML/429 → 上报给 ProxyPool（降权/禁用 `disabled_until`）
- ProxyPool 发现可用数不足 → 自动继续探测候选并补齐
- ProxyPool 发现某些代理长期低质量 → 自动轮换（按成功率/延迟/错误类型加权）

---

## 5. 既有能力保留：扫描终止线（每日）

终止线逻辑保持不变（v2 仍推荐保留）：

- `metaCharacters(game)`：由 meta 解析得到的角色集合
- `qualified(game, charId)`：角色极限面板评分达到阈值
- 当天全角色达标后，设置 `scanDisabledUntil(game)`，避免无意义重复扫描

---

## 6. 里程碑（建议）

1) **M1：TS 二次重构骨架**
- 引入 `shared/compat/core/server/ui` 分层（先迁移文件与依赖关系，不改业务）
- 运行期只加载 `dist/` 产物（入口保持 `npm start` 不变）

2) **M2：兼容层收口（JS 源数据稳定接入）**
- 所有外部输入统一 `compat/` 解析与规范化（unknown-safe）
- 错误分类与日志规范统一到 `shared/`

3) **M3：自适应并发 + 指数退避（替代手动并发）**
- 移除/忽略 `samples.enka.concurrency` 等旧字段
- WebUI 增加并发/退避状态展示（仅显示，不可手调上限）

4) **M4：代理池运行期动态扩容**
- 补齐/淘汰/轮换闭环打通（ProxyPool ⇄ Scanner）
- WebUI 增加池状态与错误分布展示

5) **M5：文档与旧实现清理**
- 清理 `rust/` 目录与旧配置项（文档/代码同步）
- 收口 README/配置/接口文档

---

## 7. 风险与注意事项

- “复用插件 UA/请求头”不保证成功率：代理 IP 质量与上游策略仍是主因，必须依赖池管理与退避策略。
- 自适应策略要可观测：否则“自动调参”会变成不可解释的黑盒，排障成本更高。
- 兼容层必须严格：宁可“丢弃不可解析样本”，也不要把坏数据推进评分/构造链路。
