# 重构计划（Roadmap）

目标：在保持 `npm start` 一键启动 + 现有 meta 兼容的前提下，提升“代理节点 → Enka 扫描 → 极限面板生成”的吞吐、稳定性与可观测性，并为后续引入 Rust 做好边界拆分。

---

## 1. 核心目标

1) **启动即并行**：`npm start` 后，WebUI 立即可用；同时“节点验证/代理池维护”和“Enka 扫描/样本写入”并行启动（不再等待完整探测结束才开始扫）。

2) **扫描终止线（每日）**：对每个游戏（`gs/sr/zzz`）增加“当日扫描终止条件”：
- 以对应 meta 定义的**角色列表**为准；
- 当该游戏的“默认极限面板（hyperpanel）”里，**每个角色的极限面板评分都达到合格阈值**后：
  - 当天不再继续扫描该游戏的 Enka API；
  - 次日（或超过 TTL）再恢复扫描，保证数据能随时间更新。

3) **Rust 重写边界**：用 Rust 重写：
- **订阅/节点解析**（多协议、容错、UTF-8 输出、性能稳定）
- **请求与限速/熔断**（批量并发 HTTP、代理支持、可观测指标）
- **日志输出**（统一格式、UTF-8 中文、可开关/分级）

同时保留 JS 实现：
- **面板解析/评分/极限面板生成**（沿用现有 meta 逻辑，确保兼容与迭代效率）

---

## 2. 现状问题（动机）

- 代理池探测需要启动内核+实际请求 Enka 才算“可用”，比简单的 TCP 测活更接近真实可用性，但耗时与波动更大。
- Enka 扫描在代理不稳定时出现大量 `fetch failed/AbortError/424`，吞吐与样本积累速度不稳定。
- 当极限面板已经“够用”时仍持续扫描，成本高且容易触发对方限流/封禁风险。
- 日志在 Windows 控制台输出存在编码/可读性问题，定位问题成本偏高。

---

## 3. 目标架构（进程内分层）

保持单进程 `node src/start.js`，但拆分为 3 个可独立运行的“子系统”（未来可替换为 Rust 实现）：

1) **ProxyPool Manager（代理池管理）**
- 订阅拉取/缓存/解析（未来 Rust）
- 节点测活（未来 Rust）
- 动态维护可用代理池（增删、降级、黑名单、失败阈值）

2) **Enka Scanner（扫描器）**
- 按游戏独立扫描状态机（cursor、retry、rescan、日终止线）
- 按代理桶限速、跨游戏轮询调度
- 产出：raw（sqlite）+ samples（jsonl）+ 统计指标

3) **Panel Builder（极限面板生成）**
- 基于 samples 生成各游戏 hyperpanel JSON
- 对接评分（与 meta 兼容，继续 JS）

WebUI：只做“配置/状态/触发”，不参与重计算。

---

## 4. 启动即并行（节点验证与扫描同时拉起）

### 4.1 目标行为

`npm start` 后立即进入以下并行状态：
- WebUI：立刻可用（可看日志/状态、可停止/重启任务）
- ProxyPool：
  - 先用“上次可用池/DB 里最近成功的节点”快速构建一个“初始池”
  - 后台继续扩大池（补齐到期望并发）
- Enka 扫描：
  - 使用“初始池”立刻开始扫（低并发/保守限速）
  - 池扩大后自动提升并发（但仍受“每代理桶 delayMs”约束）

### 4.2 关键设计点

- **代理池动态更新**：Scanner 不再只读一次 `PROXY_URLS`，而是通过“共享状态/订阅”获取可用代理列表变化。
- **失败快速剔除**：对 transport/429/html 等情况按策略禁用单个代理，避免拖慢整体。
- **探测与扫描互不阻塞**：探测失败不影响当前扫描继续；扫描发现代理不可用会反馈给池管理器（形成闭环）。

---

## 5. 扫描终止线（每日）

### 5.1 终止条件定义

对每个游戏单独维护：
- `metaCharacters(game)`：由 meta 解析得到的“角色集合”（GS/SR/ZZZ 各自定义）
- `qualified(game, charId)`：该角色当前极限面板评分是否达到阈值（阈值可配置）

当满足：
- `∀ charId ∈ metaCharacters(game): qualified(game, charId) == true`

则设置：
- `scanDisabledUntil(game) = nextDay(00:00) + jitter`（或可配置 TTL）

### 5.2 状态存储建议（SQLite）

新增表（或复用现有 scan db 的 kv/cursor 结构）：
- `scan_daily_gate(game TEXT, day TEXT, done INTEGER, done_at INTEGER, total_chars INTEGER, qualified_chars INTEGER, detail_json TEXT)`

说明：
- `day` 使用本地日期（例如 `2026-01-20`）
- `detail_json` 保存“哪些角色未达标/差多少”，便于 WebUI 展示与排障

### 5.3 触发时机

- 每次 `hyperpanel` 生成完成后计算一次 gate；
- 或每次扫描累计写入一定样本量后计算一次（避免过频）。

---

## 6. Rust 重写方案（保留 JS 评分/构造）

### 6.1 形式选择

优先推荐 **napi-rs**（Node 原生扩展）：
- Node 侧保持调用方式简单（同步/异步接口）
- Rust 侧可用 `tokio + reqwest` 做并发与超时控制

备选：独立 Rust 二进制（通过 stdin/stdout JSON-RPC 通信）：
- 开发更快、部署简单，但进程间通信与错误传播更复杂

### 6.2 Rust 模块职责

1) `sub_parser`
- 输入：订阅 URL / 原始文本（base64/Clash YAML/vmess/vless/ss/trojan/tuic/hysteria2…）
- 输出：统一 Canonical Node 列表（字段齐全、可序列化）
- 特性：强鲁棒解析、明确错误原因、UTF-8 中文日志可选

2) `probe_pool`
- 输入：node 列表 + 测活策略（testUrl、超时、并发）
- 输出：可用代理列表 + 指标（成功率、p50/p90 延迟、失败原因分布）

3) `enka_fetcher`
- 输入：game + uid 列表/范围 + 代理池 + 限速/熔断策略
- 输出：raw json（字符串）+ 状态码/错误原因（供 JS 写入 sqlite / samples）

### 6.3 JS 保留边界

保留 JS 的原因：
- meta 结构与现有构筑/评分逻辑高度耦合，JS 侧迭代成本低
- 评分对齐 miao-plugin 规则更容易复用/对比

Rust 侧只负责“拿到更稳定的原始数据 + 更快的代理池维护”。

---

## 7. 日志系统（UTF-8 中文 + 简化）

目标：
- 日志分级：`error/warn/info/debug`
- 关键路径只输出“摘要+进度”，细节写入 debug（或写 sqlite）
- 统一 UTF-8 输出，避免 Windows 控制台乱码

建议输出规范：
- `[proxy]`：只输出“探测进度、ok 列表、失败原因统计”
- `[samples]`：只输出“每批次进度、成功/失败/状态码分布、当前代理池规模”
- `[preset]`：输出“角色数、合格率、未达标角色 TopN”

---

## 8. 里程碑（建议）

1) M1：启动并行化 + 动态代理池（JS 版）
2) M2：每日扫描终止线（JS 版，先落 sqlite）
3) M3：Rust `sub_parser` 替换现有解析
4) M4：Rust `probe_pool` 替换测活（降低启动耗时、提高吞吐）
5) M5：Rust `enka_fetcher` 接管请求（JS 只做落库与评分）

---

## 9. 风险与注意事项

- “复用插件 UA/请求头”不保证成功率：代理 IP 质量与上游可用性仍是主因，需配合池管理策略。
- “终止线”要防止误判：必须基于 meta 的角色全集，且对“缺样本角色”要明确显示缺口。
- Rust/JS 边界要稳定：接口返回必须包含完整错误信息（status、body 摘要、分类），否则排障会变难。

