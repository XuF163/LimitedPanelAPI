# 极限面板 JSON 生成服务端（极限面板API）开发计划

> 目标：生成兼容 Yunzai（liangshi-calc / miao-plugin）本地 `PlayerData` 结构的预设面板 JSON（如 `100000000.json` 极限面板），并提供服务端 API 用于：同步 meta、采集 Enka 面板样本、统计“高分且常见”的圣遗物/遗器配置、合成“满命 + 满精专武 + 极限词条”面板、导出/托管 JSON。

---

## 0. 本次补充（配置 WebUI / 定时更新 / 文档整理）

### 0.1 WebUI 配置（目标）

- 目标：不依赖手改 YAML，用浏览器完成 `config/config.yaml` 的查看/修改。
- 接口规划：
  - `GET /ui`：WebUI（配置编辑页）
  - `GET /api/config?kind=user|default`：读取用户/默认配置（YAML 文本）
  - `PUT /api/config?kind=user`：写入用户配置（写入前校验 YAML；写入时生成备份）
- 安全策略：默认仅允许本机访问（可选 token 允许远程访问）。

### 0.1.x 代理池增强（补充文档）

- 节点整合/协议支持/动态维护代理池（面向并发吞吐）的开发说明见：`docs/proxy-enhancement.md`

### 0.2 meta 资源自动更新（目标）

- 目标：meta-gs/meta-sr 每天自动拉取一次，减少长期运行“版本落后”。
- 配置：`meta.autoUpdate.enabled + meta.autoUpdate.intervalSec`。

### 0.3 UID 范围定期重扫（目标）

- 目标：对已扫过的 UID 定期“复扫”，以刷新样本并让极限面板能持续更新。
- 方式：按 `last_checked_at` 最旧优先重扫（不要求重置游标）。
- 配置：`samples.enka.rescan.*`。

### 0.4 极限面板自动刷新（目标）

- 目标：周期性执行一次“采样 -> 生成 preset”，更新 `out/<game>/<uid>.json`。
- 配置：`preset.autoRefresh.*`。

### 0.5 文档整理（目标）

- 除 `README.md` 外，所有文档统一放到 `docs/`：
  - `docs/config.md`：配置说明
  - `docs/games.md`：游戏与 UID 规则
  - `docs/开发计划.md`：开发计划（本文）

## 1. 现状分析（参考 Yunzai，只读）

### 1.1 预设面板文件与 UID 约定

- liangshi-calc 预设面板文件位于：
  - `Yunzai/plugins/liangshi-calc/replace/data/<panelPath>/PlayerData/gs/100000000.json`
  - `Yunzai/plugins/liangshi-calc/replace/data/<panelPath>/PlayerData/sr/100000000.json`
- `100000000.json` 默认表示“极限面板”，`100000001.json` 等用于其它面板类型（核爆/辅助/平民…）。
- 预设面板通常会被复制到：
  - `Yunzai/data/PlayerData/gs/100000000.json`
  - `Yunzai/data/PlayerData/sr/100000000.json`
- 在现有预设数据中：`gs/100000000.json` 包含约 107 个角色，`sr/100000000.json` 包含约 59 个角色。

### 1.2 PlayerData JSON 结构（必须兼容）

#### 原神（gs）

顶层：

- `uid`：字符串（如 `"100000000"`）
- `name`：字符串（如 `"极限面板"`）
- `avatars`：对象，key 为角色 id（字符串/数字都行，但建议字符串）

单个角色（avatar）关键字段（参考 `Yunzai/plugins/liangshi-calc/apps/sharePanel.js` 与现有预设 JSON）：

- `name`、`id`、`elem`
- `level`、`promote`、`cons`、（可选）`fetter`、`costume`
- `talent: { a, e, q }`
- `weapon: { name, level, promote, affix }`
- `artis: { "1".."5": { level, star, name, mainId, attrIds } }`
  - `mainId`：圣遗物主词条 ID（例如 14001、15010 等）
  - `attrIds`：`appendPropIdList`（例如 501204 等），数组长度常见为 9（表示初始+强化词条滚动集合）
- `_source`、`_time`、`_update`、`_talent`：用于来源/更新时间（可保留）

#### 崩铁（sr）

与 gs 类似，差异：

- `talent` 通常包含 `a/e/q/t`
- `trees`：行迹点 ID 列表
- `weapon` 多为 `{ id, level, promote, affix }`
- `artis` 为 6 件：`"1".."6"`，且单件字段常为 `{ level, star, id, mainId, attrIds }`
  - `attrIds` 多为字符串 `"affixId,cnt,step"`（参考 `Yunzai/plugins/miao-plugin/models/serv/api/EnkaHSRApi.js` 内的 `EnkaHSRData.getArtis`）

### 1.3 Enka 接口与解析方式（可复用思路）

- gs：`https://enka.network/api/uid/<uid>`
  - 关键字段：`playerInfo`、`avatarInfoList`
  - 解析参考：`Yunzai/plugins/miao-plugin/models/serv/api/EnkaData.js`
- sr：`https://enka.network/api/hsr/uid/<uid>`
  - 关键字段：`detailInfo.avatarDetailList` 等
  - 解析参考：`Yunzai/plugins/miao-plugin/models/serv/api/EnkaHSRApi.js`（包含 `EnkaHSRData`）
- zzz：`https://enka.network/api/zzz/uid/<uid>`（备选：`https://profile.microgg.cn/api/zzz/uid/<uid>`）
  - 关键字段：`PlayerInfo.ShowcaseDetail.AvatarList`
  - 解析参考：`Yunzai/plugins/ZZZ-Plugin/model/Enka/enkaApi.js` 与 `Yunzai/plugins/ZZZ-Plugin/model/Enka/formater.js`

### 1.4 评分/词条换算（用于“高分筛选”）

miao-plugin 已具备将 `mainId + attrIds` 换算为主/副词条数值并计算评分的能力（但依赖 meta）：

- 词条换算：
  - `Yunzai/plugins/miao-plugin/models/artis/ArtisAttr.js`
- 圣遗物评分：
  - `Yunzai/plugins/miao-plugin/models/artis/ArtisMark.js`
  - `Yunzai/plugins/miao-plugin/models/artis/ArtisMarkCfg.js`（读取角色评分规则）
- 角色评分规则来自 meta（每个角色一个 `artis.js`）：
  - `Yunzai/plugins/miao-plugin/models/character/CharCfg.js`

### 1.5 meta 来源（可选：CNB / miao-plugin）

本项目支持两种 GS/SR meta 来源（见 `docs/config.md` 的 `meta.source`）：

1) CNB（qsyhh_res/meta，meta-gs/meta-sr 分支）

```bash
git clone -b meta-gs https://cnb.cool/qsyhh_res/meta.git "./resources/meta-gs" --depth=1
git clone -b meta-sr https://cnb.cool/qsyhh_res/meta.git "./resources/meta-sr" --depth=1
```

2) miao-plugin（从 miao-plugin 仓库中拷贝 `resources/meta-gs` / `resources/meta-sr`）

```bash
git clone https://github.com/yoimiya-kokomi/miao-plugin.git "./resources/miao-plugin" --depth=1
```

---

## 2. 极限面板API：总体目标与范围

### 2.1 产物（最小可用集）

- **导出文件**（与 Yunzai 预设一致）：
  - `out/gs/100000000.json`（极限面板）
  - `out/sr/100000000.json`（极限面板）
  - `out/zzz/10000000.json`（绝区零：极限面板/参考面板；UID 通常为 8 位；暂不评估）
- **HTTP 托管**：
  - `GET /gs/hyperpanel`
  - `GET /sr/hyperpanel`
  - `GET /zzz/hyperpanel`
  - `GET /presets/gs/100000000.json`
  - `GET /presets/sr/100000000.json`
  - `GET /presets/zzz/10000000.json`

### 2.2 非目标（首期不做或可选）

- 不做“实时”计算（首期以离线批处理+缓存为主）。
- 不默认全网扫 UID（默认只吃 UID 列表；扫段作为可选并强约束）。

---

## 3. 数据流与模块设计

### 3.1 模块拆分

1. `MetaManager`
   - 同步/更新 meta（meta-gs / meta-sr）
   - 提供查询：角色列表、武器数据、圣遗物/遗器主副词条映射、角色评分规则（artis.js）
2. `EnkaClient`
   - 统一封装 gs/sr/zzz 请求
   - 限速、并发控制、重试、错误分类（无数据/封禁/超时/格式异常）
   - 直连 +（可选）代理池：
     - 无代理/无可用节点时：跨进程全局限速（避免 429）
     - 有代理时：按代理数量分桶节流 + 并发采样
3. `SampleCollector`
   - 输入：UID 列表或（可选）UID 段策略
   - 输出：原始响应（raw）与解析后的“角色构筑样本”（build samples）
4. `ScanStateStore (SQLite)`
   - 存储 Enka 扫描状态（成功/失败/最后一次时间/下次重试时间/失败次数）
   - 标记并永久跳过“异常账号”（如 Enka 返回 `400/404`）
   - 可选保存 raw 响应（gzip）用于复现/调试（替代海量 `data/raw/<uid>.json` 小文件）
5. `BuildParser`
   - 将 Enka 响应转换为内部统一结构：
     - `charId`、`weapon`、`artifacts(relics)`、`setCounts`、`mainStats`、`subStats` 等
6. `Scorer`
   - 使用 meta 的 `artis.js` 权重 + `attrIdMap/mainIdMap` 将样本打分
   - 产出：`score`（可用 miao 的“总分/均分”口径）
7. `ConfigAggregator`
   - 对每个角色汇总：在“高分样本”中出现频次最高的配置
   - 配置粒度建议：`(套装组合 + 主词条组合)`；可选加上 `(常见武器)` 维度
8. `ExtremeSynthesizer`
   - 输入：角色 + 选定配置
   - 输出：一份“极限面板构筑”（满命、满精专武、满级，极限词条）
9. `PresetExporter`
   - 将所有角色的极限构筑组装为 `PlayerData` JSON
10. `HTTP API + JobRunner`
   - 触发同步、采集、聚合、导出；提供健康检查与产物下载

### 3.2 数据目录建议

```
极限面板API/
  data/
    meta/              # git clone meta-gs/meta-sr（或分别两个目录）
    scan.sqlite        # 扫描状态/跳过表/raw（gzip，可选）
    raw/               # （可选调试）少量落盘，避免海量小文件
      gs/<uid>.json
      sr/<uid>.json
      zzz/<uid>.json
    samples/
      gs/<charId>.jsonl
      sr/<charId>.jsonl
      zzz/<charId>.jsonl
    agg/
      gs/configs.json
      sr/configs.json
  out/
    gs/100000000.json
    sr/100000000.json
    zzz/10000000.json
```

---

## 4. 核心流程（按你给的思路落地）

### 4.1 同步 meta

- 拉取 qsyhh 的 meta 仓库（两条分支），并提供一个 `meta version`（commit hash）写入导出 JSON 的 `_meta` 字段（可选）。
- 关键要求：**生成器的 mainId/attrIds 必须来自同一份 meta**，否则 Yunzai 侧解析会错位。

### 4.2 采集面板样本（Enka）

#### 输入策略

- 默认：用户提供 UID 列表（推荐）
- 可选：UID 枚举（例如从 `242422996` 开始）
  - 必须具备强约束：最大请求数、并发、QPS、失败率熔断
  - 建议加入白名单地区（仅 1~4 开头 CN 官服等）

#### 采集输出

- 扫描状态（SQLite）：记录每个 UID 的结果、失败次数、下次重试时间、是否永久跳过
- raw（SQLite gzip，可选）：保存响应 JSON（便于重放/调试，避免海量小文件）
- samples：抽取每个角色的构筑样本（与用户账号解耦）

#### 状态码与处理策略（建议口径）

> 目标：在大规模（例如目标采样 4w UID）时可持续运行，并且“坏 UID”只处理一次。

- `200`：成功，写入样本与 raw（可选）
- `400`：UID 格式错误 → **永久标记异常 UID**，后续不再扫描
- `404`：玩家不存在（MHY 服务器说的）→ **永久标记异常 UID**，后续不再扫描
- `424`：数据服务不可用/维护/更新导致 → 记录失败 + 指数退避重试
- `429`：请求频率限制 → 记录失败 + 更激进退避（建议分钟级）或直接熔断本轮
- `500`：服务器错误 → 记录失败 + 退避重试
- `503`：服务不可用/上游异常 → 记录失败 + 退避重试

#### 代理（可选，已实现）

为提升大规模扫描稳定性/吞吐量，支持基于订阅的 **v2ray-core 代理池**：

- 解析订阅 → 过滤可用节点（支持 base64/vmess/vless/trojan/ss、部分 Clash YAML）→ 启动多个本地 HTTP 代理（代理池）
- 扫描时按代理数量**分桶节流**（每个代理独立 delay），坏代理会被自动禁用
- 当所有代理都不可用时，会提前结束本轮扫描（避免卡死/空跑），本轮已采集的样本仍可继续生成极限面板
- 注意：`enka.network` 对“空/异常 UA”会返回 HTML 403，因此测活与采样请求需携带 UA（本项目已处理）

QA 测试流程属于开发调试，不影响“仅 `npm start` + WebUI 配置”的开箱使用。

补充实现要点（已落地）：

- 扫描状态写入 `data/scan.sqlite`，并按 `(game, uid)` 维度区分（避免 gs/sr/zzz UID 相互污染）。
- 配置文件改为 YAML：
  - 默认：`config/defSet.yaml`
  - 用户：`config/config.yaml`（首次启动自动生成；仓库已忽略）
- 核验（开发调试）：对比 `out/gs/100000000.json`、`out/sr/100000000.json` 与梁氏预设数据（绝区零暂不评估）

### 4.3 “高分且常见”配置统计

对每个角色 `charId`：

1. 使用 `Scorer` 计算样本分数（例如：圣遗物总分/均分）
2. 取 Top-N 或 Top-P（如 Top 10% 且 N≥50 才生效）
3. 将配置 key 归一化并计数：
   - gs 配置 key 示例：
     - `sets: {冰风:4, ...} + main: {3:atk%, 4:cryo, 5:cdmg}`（只统计 3/4/5）
   - sr 配置 key 示例：
     - `sets: {套装A:4, 位面B:2} + main: {3:...,4:...,5:...,6:...}`
4. 选择策略：
   - 主：频次最高
   - 次：平均分更高
   - 兜底：直接使用 meta 中该角色默认评分规则推导出的主词条（或内置默认）

### 4.4 极限面板合成（满命 + 满精专武 + 极限词条）

这里是“生成 `100000000.json` 的关键”。

#### 4.4.1 专武选择

优先级建议：

1. meta 中若存在明确字段（例如角色 detail 或配置里标注 signature weapon/lightcone），直接用
2. 否则：在“高分样本”中出现频次最高的 5★武器/光锥作为“专武”
3. 再否则：回退到内置映射表（人工维护一份 `signature-weapons.json`）

统一规格：

- gs：`level=90, promote=6, affix=5`
- sr：`level=80, promote=6, affix=5`（或根据当前版本上限配置化）

#### 4.4.2 角色规格

- gs：`level=90`（或保持与现有预设一致：部分角色 `level=100`，此处需统一口径）、`cons=6`、天赋 `10/10/10`
- sr：`level=80`、`cons=6`、天赋 `10/10/10/10`（行迹树按满点策略生成）

#### 4.4.3 极限圣遗物/遗器词条生成

**目标：在不违背“词条结构约束”的前提下，生成一套“极限滚动”的 `attrIds`（gs）或 `"id,cnt,step"`（sr）。**

##### 原神（gs）规则（确定版）

- **套装/部位/主词条**：从本地缓存的样本（`data/samples/gs/<charId>.jsonl`）中，选取该角色“圣遗物评分最高”的真实玩家样本；直接拷贝其 1~5 号位圣遗物的套装与 `mainId`（不改主词条）。
  - 评分口径建议直接对齐 miao：使用 meta + 权重（`character/<name>/artis.js`）把 `mainId + attrIds` 还原为数值后算分（等价于 `ArtisMark`/`ArtisMarkCfg` 思路）。
- **副词条重生成**：对每个部位单独生成 `attrIds`：
  1. 由 `mainId -> mainKey`（meta 的 `mainIdMap`）得出该部位主词条 key，并将其加入禁用集合（副词条不得与主词条同 key）。
  2. 取该角色评分权重（`artis.js`）对应的可用副词条 key，按权重从高到低排序，依次选出 4 条（跳过禁用 key 与“不可作为副词条”的 key）。
  3. 将 4 条副词条按 **6/1/1/1** 分配“出现次数”（总计 9，对应 5★四初始词条 + 5 次强化全砸一条的极限情况）。
  4. 在 meta 的 `attrIdMap` 中为每个副词条 key 选择 **value 最大**的 `appendPropId`，并按次数重复填充得到最终 `attrIds`。
- **星级/等级**：输出统一用 `star=5, level=20`（如需严格“沿用样本”，可保持样本的 `star/level`，但 `mainId` 不变）。

##### 崩铁（sr）规则（先按两阶段实现）

1. **规则生成（快）**：基于角色权重与主词条约束，选 4 个副词条并分配滚动（首期可复用 gs 的“集中滚动”策略）。
2. **ID 具体化（依赖 meta）**：根据 meta 的 `starData.sub` 生成 `"affixId,cnt,step"` 形式的 `attrIds`，并优先取最大档组合。

兜底：若无法精确构造“完全合法”的滚动结构，至少保证：

- `mainId` 合法
- `attrIds` 中的每个 id/字符串都能被 meta 解析
- Yunzai 侧可正常渲染与参与计算（不会崩）

---

## 5. HTTP API 规划（建议）

### 5.1 只读产物

- `GET /healthz`
- `GET /ui`（WebUI：配置编辑）
- `GET /gs/hyperpanel`
- `GET /sr/hyperpanel`
- `GET /zzz/hyperpanel`
- `GET /presets/:game/:uid.json`（game=gs|sr|zzz）

### 5.2 管理接口（可加鉴权）

- `GET /api/config?kind=user|default`
- `PUT /api/config?kind=user`
- `POST /meta/sync?game=gs|sr|all`
- `POST /samples/collect`
  - body：`{ game, uids?: number[], uidStart?: number, count?: number, concurrency?: number, qps?: number }`
- `POST /configs/aggregate`
  - body：`{ game, topPercent?: number, minSamples?: number }`
- `POST /presets/generate`
  - body：`{ game, uid: "100000000", mode: "extreme" }`
- `GET /configs/:game/:charId`（调试用，返回该角色统计结果）

---

## 6. 风险与约束（必须写进实现）

1. **Enka 合规与限速**：不要默认扫段；扫段必须显式开启并设置上限（QPS/并发/总量/熔断）。
2. **坏 UID 永久跳过**：`400/404` 这类 UID 需要写入 SQLite 并永久跳过，避免 4w 规模下反复浪费请求额度。
3. **存储与 I/O**：避免把 4w raw 响应保存为海量 `*.json` 小文件；推荐 SQLite（gzip）或分片压缩文件。
4. **隐私**：仅保存“构筑样本”（角色 id、圣遗物组合等），避免持久化昵称/签名/头像等玩家信息；raw 响应应可配置是否保存。
5. **数据偏差**：样本来自特定 UID 段会导致偏差；需要支持多来源 UID 列表与“样本量不足回退策略”。
6. **meta 版本漂移**：导出 JSON 必须与解析端使用的 meta 版本一致（至少同一 major）；建议在导出中记录 meta commit。
7. **多游戏 UID 隔离**：SQLite 扫描状态必须按 `(game, uid)` 维度区分，避免 gs/sr/zzz 的 UID 相互污染。

---

## 7. 里程碑（推荐迭代顺序）

1. 初始化项目骨架（Node.js/TypeScript 可选）+ `GET /healthz` + 静态托管 `out/`
2. `MetaManager`：clone/pull meta-gs/meta-sr + 基础读取（角色列表、attrIdMap/mainIdMap）
3. `EnkaClient + ScanStateStore`：gs/sr 拉取 + 限速 + 状态码策略 + SQLite（状态/跳过/可选 raw gzip）
4. `BuildParser + Scorer`：将样本打分并输出调试报表（先只做 gs）
5. `ConfigAggregator`：输出每个角色的“最常见高分配置”
6. `ExtremeSynthesizer`：合成单角色极限构筑（先做 1~3 个角色验证）
7. `PresetExporter`：批量生成 `100000000.json`（gs/sr）
8. 回归验证：将生成的 JSON 放入 `Yunzai/data/PlayerData/...`，在 Yunzai 侧渲染/计算不报错
9. 绝区零（zzz）：接入 Enka 展柜面板解析（参考 ZZZ-Plugin），生成 `out/zzz/<uid>.json`（暂不评估）
